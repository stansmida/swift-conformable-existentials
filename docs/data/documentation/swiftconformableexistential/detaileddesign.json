{"seeAlsoSections":[{"title":"Articles","identifiers":["doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/Essentials"],"generated":true}],"sections":[],"identifier":{"url":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/DetailedDesign","interfaceLanguage":"swift"},"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/swiftconformableexistential\/detaileddesign"]}],"primaryContentSections":[{"content":[{"anchor":"Equality","level":2,"type":"heading","text":"Equality"},{"inlineContent":[{"type":"text","text":"Equality is evaluated via "},{"code":"_ConformableExistentialEquatableSupport","type":"codeVoice"},{"type":"text","text":" and"},{"type":"text","text":" "},{"code":"_ConformableExistentialEquatableSequenceSupport","type":"codeVoice"},{"type":"text","text":" internal protocols. Clients are"},{"type":"text","text":" "},{"text":"not intended to work with them directly, but the module use them to evaluate the equality of equatable","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"wrappers that clients have spawned. It enables to compare “unrelated” types:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["EquatableDrinkable(.smallBeer) == EquatableOptionalDrinkable(.smallBeer) \/\/ true","EquatableDrinkable(.smallBeer) == HashableCodableMutableOptionalDrinkable(.smallBeer) \/\/ true","EquatableCollectionOfDrinkable([.smallBeer, .glassOfWater]) == HashableOptionalCollectionOfDrinkable([.smallBeer, .glassOfWater]) \/\/ true"]},{"type":"heading","level":3,"text":"Equality of collections","anchor":"Equality-of-collections"},{"inlineContent":[{"type":"text","text":"Two wrappers over a collection of existentials are evaluated as equal if they have the same collection type"},{"text":" ","type":"text"},{"text":"and if the collections contain equal elements at respective index (have same order). Ideally, the wrapper would","type":"text"},{"type":"text","text":" "},{"text":"be declared with an “OrderedCollection” generic constraint, but no such protocol exists. Since unordered","type":"text"},{"type":"text","text":" "},{"text":"collections typically rely on ","type":"text"},{"type":"codeVoice","code":"Hashable"},{"text":" to form indices (e.g., ","type":"text"},{"type":"codeVoice","code":"Set"},{"type":"text","text":"), and existentials cannot conform"},{"type":"text","text":" "},{"type":"text","text":"to "},{"code":"Hashable","type":"codeVoice"},{"type":"text","text":" ("},{"type":"codeVoice","code":"Set<any Drinkable>"},{"text":" is ill-formed), it is very unlikely that this would become a problem","type":"text"},{"type":"text","text":" "},{"type":"text","text":"for clients. However, in such an unlikely case, clients can still resolve this issue by implementing"},{"type":"text","text":" "},{"type":"text","text":"their own == operator on the wrapper that wraps the unordered collection."}],"type":"paragraph"},{"level":2,"anchor":"Rationales","type":"heading","text":"Rationales"},{"level":3,"type":"heading","text":"Composited conformances","anchor":"Composited-conformances"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The main reason for the existence of "},{"type":"codeVoice","code":"HashableCodableExistential"},{"type":"text","text":" (and other composite variants),"},{"text":" ","type":"text"},{"text":"in addition to the standalone ","type":"text"},{"type":"codeVoice","code":"HashableExistential"},{"text":" and ","type":"text"},{"code":"CodableExistential","type":"codeVoice"},{"text":", is the limitation in","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"the composition of property wrappers ("},{"text":" ","type":"text"},{"type":"reference","identifier":"https:\/\/github.com\/apple\/swift-evolution\/blob\/main\/proposals\/0258-property-wrappers.md#composition-of-property-wrappers","isActive":true},{"text":",","type":"text"},{"type":"text","text":" "},{"type":"reference","identifier":"https:\/\/github.com\/apple\/swift-evolution\/blob\/main\/proposals\/0258-property-wrappers.md#composition","isActive":true},{"text":" ","type":"text"},{"type":"text","text":")."}]},{"type":"codeListing","syntax":"swift","code":["struct Container: Hashable, Codable {","","    \/\/ Is ill-formed `HashableDrinkable<CodableDrinkable<DrinkableTypeCoding>>` because","    \/\/ `CodableDrinkable` doesn't conform to `Hashable`. ","    @HashableDrinkable","    @CodableDrinkable<DrinkableTypeCoding>","    let drinkable: any Drinkable","}"]},{"inlineContent":[{"type":"text","text":"This limitation leaves us with the only option - to satisfy both "},{"type":"codeVoice","code":"Hashable"},{"type":"text","text":" and "},{"type":"codeVoice","code":"Codable"},{"text":" requirements","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"in a single wrapper."}],"type":"paragraph"},{"syntax":"swift","code":["struct Container: Hashable, Codable {","","    @HashableCodableDrinkable<DrinkableTypeCoding>","    var drinkable: any Drinkable","}"],"type":"codeListing"},{"type":"heading","anchor":"TypeCoding-generic-expression","level":3,"text":"`TypeCoding` generic expression"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A codable wrapper does not take a "},{"type":"codeVoice","code":"TypeCoding"},{"text":" parameter in its initializer; instead, it is expressed","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"as a generic parameter. This allows compilation without forcing clients to initialize with arbitrarily"},{"text":" ","type":"text"},{"type":"text","text":"chosen “dumb” values."}]},{"type":"codeListing","code":["\/\/ Wouldn't compile; perhaps once - https:\/\/forums.swift.org\/t\/allow-property-wrappers-with-multiple-arguments-to-defer-initialization-when-wrappedvalue-is-not-specified\/38319","@HashableCodableDrinkable(with: DrinkableTypeCoding())","var drinkable: any Drinkable","","\/\/ It would compile, but would force clients to initialize it with a fabricated value.","@HashableCodableDrinkable(with: DrinkableTypeCoding())","var drinkable: any Drinkable = .smallBeer","","\/\/ The chosen expression compiles and allows `drinkable` to be defined in intialization.","@HashableCodableDrinkable<DrinkableTypeCoding>","var drinkable: any Drinkable"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"The static nature of ","type":"text"},{"type":"codeVoice","code":"TypeCoding"},{"text":" generic parameter has also another benefit -","type":"text"},{"type":"text","text":" "},{"text":"the statically-defined information protects clients from loading unexpected data,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"similar to the protection provided by NSSecureCoding ("},{"type":"reference","identifier":"https:\/\/developer.apple.com\/documentation\/foundation\/codableconfiguration#overview","isActive":true},{"text":").","type":"text"}]},{"level":3,"text":"`C` generic parameter in collection wrappers","type":"heading","anchor":"C-generic-parameter-in-collection-wrappers"},{"inlineContent":[{"type":"text","text":"To also support collections of existentials, the macros provide wrappers for these collections."},{"text":" ","type":"text"},{"text":"These wrappers are generic, allowing you to choose your specific collection type.","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["@HashableCollectionOfDrinkable","var drinkablesArray: [any Drinkable]","","@HashableCollectionOfDrinkable","var drinkablesDeque: Deque<any Drinkable>"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Decodable (and by implication, Codable) collection wrappers require the collection to be a "},{"type":"codeVoice","code":"RangeReplaceableCollection"},{"text":".","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"This is because their implementation depends on the "},{"code":"RangeReplaceableCollection.init<S>(_ elements: S)","type":"codeVoice"},{"type":"text","text":" constructor"},{"text":" ","type":"text"},{"text":"when instantiating the collection from decoded elements. All the other wrappers utilize the most abstract","type":"text"},{"type":"text","text":" "},{"code":"Sequence","type":"codeVoice"},{"type":"text","text":" protocol."}]},{"text":"Alternatives considered","anchor":"Alternatives-considered","type":"heading","level":4},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"Express it by postfixig the protocol name with “s”, e.g. "},{"code":"HashableDrinkables","type":"codeVoice"},{"type":"text","text":" instead of"},{"text":" ","type":"text"},{"code":"HashableCollectionOfDrinkable","type":"codeVoice"},{"type":"text","text":". This would break the macro’s "},{"type":"codeVoice","code":"names: prefixed"},{"text":" declaration.","type":"text"}],"type":"paragraph"}]}]}],"kind":"content"}],"metadata":{"roleHeading":"Article","role":"article","modules":[{"name":"SwiftConformableExistential"}],"title":"Detailed design"},"schemaVersion":{"minor":3,"patch":0,"major":0},"kind":"article","hierarchy":{"paths":[["doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential"]]},"references":{"https://developer.apple.com/documentation/foundation/codableconfiguration#overview":{"url":"https:\/\/developer.apple.com\/documentation\/foundation\/codableconfiguration#overview","title":"1","type":"link","identifier":"https:\/\/developer.apple.com\/documentation\/foundation\/codableconfiguration#overview","titleInlineContent":[{"type":"text","text":"1"}]},"doc://SwiftConformableExistential/documentation/SwiftConformableExistential/Essentials":{"abstract":[],"identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/Essentials","type":"topic","title":"Essentials","url":"\/documentation\/swiftconformableexistential\/essentials","kind":"article","role":"article"},"doc://SwiftConformableExistential/documentation/SwiftConformableExistential":{"identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential","kind":"symbol","url":"\/documentation\/swiftconformableexistential","abstract":[{"text":"A set of Swift Macros designed to facilitate the conformance of existential types to","type":"text"},{"text":" ","type":"text"},{"code":"Equatable","type":"codeVoice"},{"text":", ","type":"text"},{"code":"Hashable","type":"codeVoice"},{"type":"text","text":", "},{"type":"codeVoice","code":"Decodable"},{"type":"text","text":", "},{"code":"Encodable","type":"codeVoice"},{"text":", and ","type":"text"},{"type":"codeVoice","code":"Codable"},{"text":".","type":"text"}],"title":"SwiftConformableExistential","type":"topic","role":"collection"},"https://github.com/apple/swift-evolution/blob/main/proposals/0258-property-wrappers.md#composition":{"url":"https:\/\/github.com\/apple\/swift-evolution\/blob\/main\/proposals\/0258-property-wrappers.md#composition","type":"link","title":"2","identifier":"https:\/\/github.com\/apple\/swift-evolution\/blob\/main\/proposals\/0258-property-wrappers.md#composition","titleInlineContent":[{"text":"2","type":"text"}]},"https://github.com/apple/swift-evolution/blob/main/proposals/0258-property-wrappers.md#composition-of-property-wrappers":{"identifier":"https:\/\/github.com\/apple\/swift-evolution\/blob\/main\/proposals\/0258-property-wrappers.md#composition-of-property-wrappers","type":"link","url":"https:\/\/github.com\/apple\/swift-evolution\/blob\/main\/proposals\/0258-property-wrappers.md#composition-of-property-wrappers","title":"1","titleInlineContent":[{"type":"text","text":"1"}]}}}
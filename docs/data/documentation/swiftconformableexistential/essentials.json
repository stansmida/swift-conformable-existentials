{"metadata":{"role":"article","title":"Essentials","roleHeading":"Article","modules":[{"name":"SwiftConformableExistential"}]},"hierarchy":{"paths":[["doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential"]]},"seeAlsoSections":[{"generated":true,"identifiers":["doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/DetailedDesign"],"title":"Articles"}],"primaryContentSections":[{"kind":"content","content":[{"text":"Applying the macros","level":2,"anchor":"Applying-the-macros","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"This package provides macros that synthesize property wrappers for the existential type","type":"text"},{"text":" ","type":"text"},{"text":"of an annotated protocol. Unlike the existential type itself, these wrappers do conform to","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"the protocols they represent. These can be "},{"code":"Equatable","type":"codeVoice"},{"type":"text","text":", "},{"type":"codeVoice","code":"Hashable"},{"text":", ","type":"text"},{"code":"Decodable","type":"codeVoice"},{"text":", ","type":"text"},{"code":"Encodable","type":"codeVoice"},{"text":",","type":"text"},{"type":"text","text":" "},{"text":"and ","type":"text"},{"code":"Codable","type":"codeVoice"},{"text":", or any combination thereof. To specify the conformance of the synthesized wrappers,","type":"text"},{"text":" ","type":"text"},{"text":"choose the respective macro:","type":"text"}]},{"items":[{"content":[{"inlineContent":[{"identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/EquatableExistential(accessModifier:)","type":"reference","isActive":true}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"isActive":true,"type":"reference","identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/HashableExistential(accessModifier:)"}]}]},{"content":[{"inlineContent":[{"identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/DecodableExistential(accessModifier:)","type":"reference","isActive":true}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"isActive":true,"identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/EncodableExistential(accessModifier:)","type":"reference"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"isActive":true,"identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/CodableExistential(accessModifier:)","type":"reference"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"reference","isActive":true,"identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/EquatableDecodableExistential(accessModifier:)"}]}]},{"content":[{"inlineContent":[{"identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/EquatableEncodableExistential(accessModifier:)","isActive":true,"type":"reference"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"isActive":true,"type":"reference","identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/EquatableCodableExistential(accessModifier:)"}]}]},{"content":[{"inlineContent":[{"isActive":true,"identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/HashableDecodableExistential(accessModifier:)","type":"reference"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/HashableEncodableExistential(accessModifier:)","isActive":true,"type":"reference"}]}]},{"content":[{"inlineContent":[{"isActive":true,"type":"reference","identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/HashableCodableExistential(accessModifier:)"}],"type":"paragraph"}]}],"type":"unorderedList"},{"inlineContent":[{"type":"text","text":"Apply a macro by attaching it to a protocol."}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["@HashableCodableExistential","protocol Drinkable: Hashable, Codable {","    var milliliters: Double { get }","}"]},{"style":"warning","name":"Warning","content":[{"type":"paragraph","inlineContent":[{"text":"The annotated protocol must explicitly inherit from protocols in the annotation macro.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"For example:"}]},{"syntax":"swift","code":["@HashableCodableExistential","protocol Drinkable: Hashable, Codable {}"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"It does not have to match the conformances exactly though:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["\/\/ Ok because `Hashable` implies `Equatable` ","\/\/ and `Codable` implies `Encodable`.","@EquatableEncodableExistential","protocol Drinkable: Hashable, Codable {}"]}],"type":"aside"},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""},{"overridingTitle":"Understand","identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/DetailedDesign#Composited-conformances","overridingTitleInlineContent":[{"type":"text","text":"Understand"}],"isActive":true,"type":"reference"},{"type":"text","text":" why multiple"},{"type":"text","text":" "},{"type":"text","text":"conformances form a single composite wrapper."}]}],"name":"Note","type":"aside","style":"note"},{"level":2,"type":"heading","text":"Synthesized property wrappers","anchor":"Synthesized-property-wrappers"},{"inlineContent":[{"type":"text","text":"Every applied macro synthesizes property wrappers for the existential type, conforming to the protocols"},{"type":"text","text":" "},{"text":"the macro specifies. They come in regular, mutable, optional, collection, and any combination thereof variants.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Specifically, each applied macro generates the following 8 wrapper variants:"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"regular"}]}]}]},{"content":[{"inlineContent":[{"type":"emphasis","inlineContent":[{"text":"mutable","type":"text"}]}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"optional","type":"text"}],"type":"emphasis"}]}]},{"content":[{"inlineContent":[{"inlineContent":[{"text":"mutable optional","type":"text"}],"type":"emphasis"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"emphasis","inlineContent":[{"text":"collection","type":"text"}]}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"mutable collection"}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"optional collection"}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"text":"mutable optional collection","type":"text"}]}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The formula for synthesized wrapper name is "},{"code":"{conformance}{variant}{protocol name}","type":"codeVoice"},{"type":"text","text":"."},{"text":" ","type":"text"},{"text":"For instance, attaching ","type":"text"},{"code":"@HashableExistential","type":"codeVoice"},{"text":" to ","type":"text"},{"type":"codeVoice","code":"Drinkable"},{"text":" synthesizes these 8","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"property wrappers:"}]},{"code":["HashableDrinkable","HashableMutableDrinkable","HashableOptionalDrinkable","HashableCollectionOfDrinkable<C> where C: Sequence<any Drinkable>","HashableMutableOptionalDrinkable","HashableMutableCollectionOfDrinkable<C> where C: Sequence<any Drinkable>","HashableOptionalCollectionOfDrinkable<C> where C: Sequence<any Drinkable>","HashableMutableOptionalCollectionOfDrinkable<C> where C: Sequence<any Drinkable>"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"Collection variant wrappers are generic, allowing you to choose your specific collection type.","type":"text"}]},{"type":"codeListing","code":["@HashableCollectionOfDrinkable","var drinkablesArray: [any Drinkable]","","@HashableCollectionOfDrinkable","var drinkablesDeque: Deque<any Drinkable>"],"syntax":"swift"},{"inlineContent":[{"type":"text","text":"Decodable (and by implication, Codable) collection wrappers require the collection to be a "},{"type":"codeVoice","code":"RangeReplaceableCollection"},{"text":".","type":"text"},{"type":"text","text":" "},{"type":"text","text":"This is because their implementation depends on the "},{"code":"RangeReplaceableCollection.init<S>(_ elements: S)","type":"codeVoice"},{"type":"text","text":" constructor"},{"type":"text","text":" "},{"type":"text","text":"when instantiating the collection from decoded elements. All the other wrappers utilize the most abstract"},{"text":" ","type":"text"},{"type":"codeVoice","code":"Sequence"},{"type":"text","text":" protocol."}],"type":"paragraph"},{"anchor":"Utilizing-synthesized-property-wrappers","text":"Utilizing synthesized property wrappers","level":2,"type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Every synthesized wrapper is "},{"code":"@propertyWrapper","type":"codeVoice"},{"type":"text","text":". This enables the annotation of properties of"},{"text":" ","type":"text"},{"text":"the existential type. This example also illustrates the significance of all variants:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["\/\/ Mutable variants allows mutating,","\/\/ e.g. `container.mutableDrinkable = .doubleEspresso`","\/\/ in comparison to non-mutable `drinkable`.","\/\/","\/\/ `TypeCoding` generic parameter is described further below","\/\/ in \"Coding\" section.","struct Container: Hashable, Codable {","","    @HashableCodableDrinkable<DrinkableTypeCoding>","    var drinkable: any Drinkable","","    @HashableCodableMutableDrinkable<DrinkableTypeCoding>","    var mutableDrinkable: any Drinkable","","    @HashableCodableOptionalDrinkable<DrinkableTypeCoding>","    var optionalDrinkable: (any Drinkable)?","","    @HashableCodableMutableOptionalDrinkable<DrinkableTypeCoding>","    var mutableOptionalDrinkable: (any Drinkable)?","    ","    @HashableCodableCollectionOfDrinkable<[any Drinkable], DrinkableTypeCoding>","    var drinkables: [any Drinkable]","","    @HashableCodableMutableCollectionOfDrinkable<[any Drinkable], DrinkableTypeCoding>","    var mutableDrinkables: [any Drinkable]","","    @HashableCodableOptionalCollectionOfDrinkable<[any Drinkable], DrinkableTypeCoding>","    var optionalDrinkables: [any Drinkable]?","","    @HashableCodableMutableOptionalCollectionOfDrinkable<[any Drinkable], DrinkableTypeCoding>","    var mutableOptionalDrinkables: [any Drinkable]?","}"]},{"inlineContent":[{"text":"This makes all the properties ","type":"text"},{"type":"codeVoice","code":"Hashable"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"Codable"},{"type":"text","text":", allowing the compiler to synthesize "},{"type":"codeVoice","code":"Hashable"},{"text":" ","type":"text"},{"type":"text","text":"and "},{"type":"codeVoice","code":"Codable"},{"text":" implementations for ","type":"text"},{"code":"Container","type":"codeVoice"},{"text":".","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"All the wrappers project ","type":"text"},{"type":"codeVoice","code":"self"},{"type":"text","text":". This enables the use of projection when passing generic arguments:"}]},{"syntax":"swift","code":["let uniques = Set(container.$drinkables)"],"type":"codeListing"},{"inlineContent":[{"text":"Alternatively, the wrappers can also be used on-the-fly, particularly in situations where employing","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"property wrappers is not suitable:"}],"type":"paragraph"},{"code":["struct Tap: View {","","    @State private var drinkable: any Drinkable = .smallBeer","    ","    var body: some View {","        ...           ","        .onChange(of: HashableCodableDrinkable<DrinkableTypeCoding>(drinkable)) { _, newValue in","            runAnimation(for: newValue.wrappedValue)","        }","    }","","    private func submit() {","        do {","            let data = try encoder.encode(HashableCodableDrinkable<DrinkableTypeCoding>(drinkable))","            try client.push(data)","        } catch { ... }","    }","}"],"syntax":"swift","type":"codeListing"},{"syntax":"swift","type":"codeListing","code":["\/\/ `drinkalbes` in the scope are of `[any Drinkable]`","let drinkablesSet = Set(drinkables.map({ HashableDrinkable($0) }))"]},{"level":3,"type":"heading","anchor":"Mitigating-cumbersomeness-and-verbosity-of-synthesized-wrappers","text":"Mitigating cumbersomeness and verbosity of synthesized wrappers"},{"content":[{"inlineContent":[{"type":"text","text":"With 11 macros available, each generating 8 wrappers to address all supported variants,"},{"text":" ","type":"text"},{"text":"the task of clearly identifying the conformance and variant of all 88 wrappers leads to","type":"text"},{"type":"text","text":" "},{"text":"arguably cumbersome naming. To maintain clarity while mitigating this complexity,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"once you’re acquainted with their characteristics, you can simplify their usage with"},{"type":"text","text":" "},{"type":"codeVoice","code":"typealias"},{"text":", achieving more concise spelling:","type":"text"}],"type":"paragraph"},{"code":["typealias AnyDrinkables = HashableCodableCollectionOfDrinkable<[any Drinkable], DrinkableTypeCoding>","\/\/ Or if you want to stick with just the type coding but not the collection type:","typealias AnyDrinkables<C> = HashableCodableCollectionOfDrinkable<C, DrinkableTypeCoding> where C: RangeReplaceableCollection<any Drinkable>","","@AnyDrinkables ","var drinkables: [any Drinkable]","","try encoder.encode(AnyDrinkables([.smallBeer]))"],"type":"codeListing","syntax":"swift"}],"type":"aside","name":"Tip","style":"tip"},{"type":"paragraph","inlineContent":[{"text":"Applying multiple macros to a protocol is also allowed:","type":"text"}]},{"code":["@EquatableExistential \/\/ use less verbose `EquatableDrinkable` in places with just `Equatable` generic constraint","@HashableCodableExistential ","protocol Drinkable: Hashable, Codable {}"],"syntax":"swift","type":"codeListing"},{"type":"heading","level":2,"text":"Coding","anchor":"Coding"},{"inlineContent":[{"text":"While hashing and evaluating equality of existentials can be done based on the wrapped existential","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"value itself, coding presents a fundamental challenge. Specifically, decoding from an external"},{"type":"text","text":" "},{"type":"text","text":"representation becomes impossible without knowing the concrete type."}],"type":"paragraph"},{"code":["struct DecodableDrinkable: Decodable {","","    let wrappedValue: any Drinkable","","    init(from decoder: Decoder) throws {","        wrappedValue = \/\/ What type are we supposed to decode? ","    }"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"To decode an existential, resolving the concrete type from the external representation is required first.","type":"text"},{"type":"text","text":" "},{"text":"The synthesized codable wrappers accomplish this via their ","type":"text"},{"type":"codeVoice","code":"TypeDecoding"},{"type":"text","text":" generic parameter."},{"text":" ","type":"text"},{"text":"Similarly, the ","type":"text"},{"type":"codeVoice","code":"TypeEncoding"},{"type":"text","text":" generic parameter is responsible for encoding the type information,"},{"text":" ","type":"text"},{"text":"ensuring the value can be correctly decoded.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The most straightforward way to implement "},{"code":"TypeCoding","type":"codeVoice"},{"type":"text","text":" is by adopting "},{"type":"reference","identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/ProtocolMetatypeRepresentable","isActive":true},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"This type is designed to facilitate conversion back and forth between a metatype and its custom codable representation."},{"text":" ","type":"text"},{"type":"text","text":"It also includes coding key information, enabling the decoding and encoding of type information."}]},{"inlineContent":[{"type":"text","text":"An example of implementing "},{"type":"reference","identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/ProtocolMetatypeRepresentable","isActive":true},{"text":" for ","type":"text"},{"code":"Drinkable","type":"codeVoice"},{"type":"text","text":":"}],"type":"paragraph"},{"code":["enum DrinkableTypeCoding: String, ProtocolMetatypeRepresentable {","","    case beer, espresso, water","","    init?(_ type: any Drinkable.Type) {","        switch type {","            case is Beer.Type: self = .beer","            case is Espresso.Type: self = .espresso","            case is Water.Type: self = .water","            default: return nil","        }","    }","","    static let codingKey = AdHocCodingKey(stringValue: \"__type\")","","    var type: any Drinkable.Type {","        switch self {","            case .beer: Beer.self","            case .espresso: Espresso.self","            case .water: Water.self","        }","    }","}"],"type":"codeListing","syntax":"swift"},{"syntax":"swift","code":["\/\/ Tip: Sugar your DrinkableTypeCoding codable wrappers","typealias AnyDrinkables = HashableCodableCollectionOfDrinkable<[any Drinkable], DrinkableTypeCoding>","","let data = try! encoder.encode(AnyDrinkables([Espresso(milliliters: 20.0), Water(milliliters: 250.0)]))","print(String(data: data, encoding: .utf8)!)"],"type":"codeListing"},{"code":["[","  {","    \"__type\" : \"espresso\",","    \"milliliters\" : 20","  },","  {","    \"__type\" : \"water\",","    \"milliliters\" : 250","  }","]"],"type":"codeListing","syntax":"json"},{"code":["let decoded = try! decoder.decode(AnyDrinkables.self, from: data)","print(decoded.wrappedValue) \/\/ [Espresso(milliliters: 20.0), Water(milliliters: 250.0)]"],"syntax":"swift","type":"codeListing"},{"style":"tip","content":[{"type":"paragraph","inlineContent":[{"text":"Make your ","type":"text"},{"type":"codeVoice","code":"DrinkableTypeCoding"},{"text":" statically exhaustive.","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["protocol Drinkable {","    ...","    \/\/ Enforce every adopter to provide its `DrinkableTypeCoding`.","    static var typeRepresentation: DrinkableTypeCoding { get }","    ...","}","enum DrinkableTypeCoding: String, ProtocolMetatypeRepresentable {","    ...","    \/\/ Now, every Drinkable metatype has its compile-time representation.","    init?(_ type: any Drinkable.Type) {","        self = type.typeRepresentation","    }","    ..."]}],"type":"aside","name":"Tip"},{"type":"heading","text":"More abstract type coding strategies","anchor":"More-abstract-type-coding-strategies","level":3},{"inlineContent":[{"type":"reference","identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/ProtocolMetatypeRepresentable","isActive":true},{"type":"text","text":" is essentially a high-level API that conforms to "},{"identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/MetaCoding","isActive":true,"type":"reference"},{"text":".","type":"text"},{"text":" ","type":"text"},{"code":"TypeCoding","type":"codeVoice"},{"type":"text","text":" is specifically constrained to "},{"identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/MetaCoding","isActive":true,"type":"reference"},{"type":"text","text":" alone. If you need a more hands-on approach"},{"type":"text","text":" "},{"text":"to discovering types, or in representing them, conform your ","type":"text"},{"code":"TypeCoding","type":"codeVoice"},{"text":" to just ","type":"text"},{"type":"reference","identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/MetaCoding","isActive":true},{"type":"text","text":" "},{"text":"or ","type":"text"},{"isActive":true,"identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/MetaDecoding","type":"reference"},{"text":" \/ ","type":"text"},{"identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/MetaEncoding","isActive":true,"type":"reference"},{"type":"text","text":" for one-way type coding, to implement your arbitrary conversion"},{"type":"text","text":" "},{"text":"between a protocol metatype and its external representation.","type":"text"}],"type":"paragraph"},{"level":3,"text":"Encoding nil values","anchor":"Encoding-nil-values","type":"heading"},{"inlineContent":[{"text":"If your external representation format specification requires ","type":"text"},{"type":"codeVoice","code":"nil"},{"type":"text","text":" values of optional"},{"text":" ","type":"text"},{"code":"(any Drinkable)?","type":"codeVoice"},{"text":", or ","type":"text"},{"type":"codeVoice","code":"[any Drinkable]?"},{"type":"text","text":" to encode explicitly as null values, you can configure"},{"type":"text","text":" "},{"type":"text","text":"this behavior in your "},{"code":"TypeEncoding","type":"codeVoice"},{"type":"text","text":" via "},{"isActive":true,"identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/OptionalExistentialEncodingConfig","type":"reference"},{"text":".","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["enum DrinkableTypeCoding: String, OptionalExistentialEncodingConfig, ProtocolMetatypeRepresentable {","    ...","    static let shouldEncodeNil = true","    ...","}"],"type":"codeListing"},{"inlineContent":[{"text":"This configuration makes ","type":"text"},{"type":"codeVoice","code":"HashableCodableOptionalDrinkable<DrinkableTypeCoding>(nil)"},{"text":" to explicitly encode","type":"text"},{"type":"text","text":" "},{"type":"text","text":"as "},{"type":"codeVoice","code":"null"},{"text":", as opposed to omitting the ","type":"text"},{"type":"codeVoice","code":"nil"},{"type":"text","text":" value during encoding."}],"type":"paragraph"},{"level":2,"text":"More info","type":"heading","anchor":"More-info"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"reference","identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/DetailedDesign","isActive":true}],"type":"paragraph"}]}]}]}],"variants":[{"paths":["\/documentation\/swiftconformableexistential\/essentials"],"traits":[{"interfaceLanguage":"swift"}]}],"schemaVersion":{"patch":0,"major":0,"minor":3},"kind":"article","sections":[],"identifier":{"url":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/Essentials","interfaceLanguage":"swift"},"references":{"doc://SwiftConformableExistential/documentation/SwiftConformableExistential/HashableExistential(accessModifier:)":{"type":"topic","role":"symbol","identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/HashableExistential(accessModifier:)","abstract":[{"type":"text","text":"Synthetizes "},{"code":"Hashable","type":"codeVoice"},{"text":" property wrapper variants (regular, mutable, optional, collection and their combinations)","type":"text"},{"text":" ","type":"text"},{"text":"over existentials of the annotated protocol.","type":"text"}],"kind":"symbol","title":"HashableExistential(accessModifier:)","fragments":[{"kind":"keyword","text":"macro"},{"text":" ","kind":"text"},{"text":"HashableExistential","kind":"identifier"},{"text":"(","kind":"text"},{"kind":"externalParam","text":"accessModifier"},{"kind":"text","text":": "},{"kind":"typeIdentifier","preciseIdentifier":"s:17SwiftSyntaxExtras18TypeAccessModifierO","text":"TypeAccessModifier"},{"kind":"text","text":"?)"}],"url":"\/documentation\/swiftconformableexistential\/hashableexistential(accessmodifier:)"},"doc://SwiftConformableExistential/documentation/SwiftConformableExistential/OptionalExistentialEncodingConfig":{"identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/OptionalExistentialEncodingConfig","title":"OptionalExistentialEncodingConfig","url":"\/documentation\/swiftconformableexistential\/optionalexistentialencodingconfig","abstract":[{"type":"text","text":"A way to tell encodable optional existential wrapper to encode nil."}],"navigatorTitle":[{"text":"OptionalExistentialEncodingConfig","kind":"identifier"}],"type":"topic","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"OptionalExistentialEncodingConfig"}],"role":"symbol","kind":"symbol"},"doc://SwiftConformableExistential/documentation/SwiftConformableExistential/EncodableExistential(accessModifier:)":{"title":"EncodableExistential(accessModifier:)","url":"\/documentation\/swiftconformableexistential\/encodableexistential(accessmodifier:)","fragments":[{"text":"macro","kind":"keyword"},{"kind":"text","text":" "},{"text":"EncodableExistential","kind":"identifier"},{"text":"(","kind":"text"},{"kind":"externalParam","text":"accessModifier"},{"text":": ","kind":"text"},{"preciseIdentifier":"s:17SwiftSyntaxExtras18TypeAccessModifierO","text":"TypeAccessModifier","kind":"typeIdentifier"},{"text":"?)","kind":"text"}],"role":"symbol","abstract":[{"type":"text","text":"Synthetizes "},{"type":"codeVoice","code":"Encodable"},{"type":"text","text":" property wrapper variants (regular, mutable, optional, collection and their combinations)"},{"type":"text","text":" "},{"text":"over existentials of the annotated protocol.","type":"text"}],"type":"topic","kind":"symbol","identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/EncodableExistential(accessModifier:)"},"doc://SwiftConformableExistential/documentation/SwiftConformableExistential/HashableEncodableExistential(accessModifier:)":{"kind":"symbol","title":"HashableEncodableExistential(accessModifier:)","identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/HashableEncodableExistential(accessModifier:)","type":"topic","fragments":[{"kind":"keyword","text":"macro"},{"text":" ","kind":"text"},{"kind":"identifier","text":"HashableEncodableExistential"},{"kind":"text","text":"("},{"kind":"externalParam","text":"accessModifier"},{"text":": ","kind":"text"},{"kind":"typeIdentifier","preciseIdentifier":"s:17SwiftSyntaxExtras18TypeAccessModifierO","text":"TypeAccessModifier"},{"kind":"text","text":"?)"}],"url":"\/documentation\/swiftconformableexistential\/hashableencodableexistential(accessmodifier:)","abstract":[{"text":"Synthetizes ","type":"text"},{"code":"Hashable & Encodable","type":"codeVoice"},{"type":"text","text":" property wrapper variants (regular, mutable, optional, collection and their combinations)"},{"text":" ","type":"text"},{"type":"text","text":"over existentials of the annotated protocol."}],"role":"symbol"},"doc://SwiftConformableExistential/documentation/SwiftConformableExistential/HashableDecodableExistential(accessModifier:)":{"identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/HashableDecodableExistential(accessModifier:)","abstract":[{"type":"text","text":"Synthetizes "},{"type":"codeVoice","code":"Hashable & Decodable"},{"type":"text","text":" property wrapper variants (regular, mutable, optional, collection and their combinations)"},{"text":" ","type":"text"},{"type":"text","text":"over existentials of the annotated protocol."}],"url":"\/documentation\/swiftconformableexistential\/hashabledecodableexistential(accessmodifier:)","title":"HashableDecodableExistential(accessModifier:)","type":"topic","fragments":[{"text":"macro","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"HashableDecodableExistential"},{"text":"(","kind":"text"},{"kind":"externalParam","text":"accessModifier"},{"text":": ","kind":"text"},{"kind":"typeIdentifier","preciseIdentifier":"s:17SwiftSyntaxExtras18TypeAccessModifierO","text":"TypeAccessModifier"},{"kind":"text","text":"?)"}],"role":"symbol","kind":"symbol"},"doc://SwiftConformableExistential/documentation/SwiftConformableExistential/CodableExistential(accessModifier:)":{"identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/CodableExistential(accessModifier:)","type":"topic","url":"\/documentation\/swiftconformableexistential\/codableexistential(accessmodifier:)","fragments":[{"kind":"keyword","text":"macro"},{"text":" ","kind":"text"},{"text":"CodableExistential","kind":"identifier"},{"text":"(","kind":"text"},{"text":"accessModifier","kind":"externalParam"},{"kind":"text","text":": "},{"preciseIdentifier":"s:17SwiftSyntaxExtras18TypeAccessModifierO","kind":"typeIdentifier","text":"TypeAccessModifier"},{"text":"?)","kind":"text"}],"abstract":[{"type":"text","text":"Synthetizes "},{"code":"Codable","type":"codeVoice"},{"type":"text","text":" property wrapper variants (regular, mutable, optional, collection and their combinations)"},{"type":"text","text":" "},{"text":"over existentials of the annotated protocol.","type":"text"}],"kind":"symbol","role":"symbol","title":"CodableExistential(accessModifier:)"},"doc://SwiftConformableExistential/documentation/SwiftConformableExistential/ProtocolMetatypeRepresentable":{"navigatorTitle":[{"text":"ProtocolMetatypeRepresentable","kind":"identifier"}],"abstract":[{"text":"A type that can be converted to and from an associated value where the value","type":"text"},{"type":"text","text":" "},{"text":"is meant to be a protocol metatype.","type":"text"}],"fragments":[{"text":"protocol","kind":"keyword"},{"kind":"text","text":" "},{"text":"ProtocolMetatypeRepresentable","kind":"identifier"}],"identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/ProtocolMetatypeRepresentable","url":"\/documentation\/swiftconformableexistential\/protocolmetatyperepresentable","type":"topic","title":"ProtocolMetatypeRepresentable","kind":"symbol","role":"symbol"},"doc://SwiftConformableExistential/documentation/SwiftConformableExistential/MetaEncoding":{"kind":"symbol","identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/MetaEncoding","type":"topic","url":"\/documentation\/swiftconformableexistential\/metaencoding","title":"MetaEncoding","role":"symbol","fragments":[{"text":"protocol","kind":"keyword"},{"kind":"text","text":" "},{"text":"MetaEncoding","kind":"identifier"}],"abstract":[{"text":"A type that encodes meta information.","type":"text"}],"navigatorTitle":[{"text":"MetaEncoding","kind":"identifier"}]},"doc://SwiftConformableExistential/documentation/SwiftConformableExistential/DetailedDesign":{"identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/DetailedDesign","abstract":[],"title":"Detailed design","type":"topic","kind":"article","url":"\/documentation\/swiftconformableexistential\/detaileddesign","role":"article"},"doc://SwiftConformableExistential/documentation/SwiftConformableExistential/EquatableExistential(accessModifier:)":{"identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/EquatableExistential(accessModifier:)","abstract":[{"type":"text","text":"Synthetizes "},{"type":"codeVoice","code":"Equatable"},{"type":"text","text":" property wrapper variants (regular, mutable, optional, collection and their combinations)"},{"text":" ","type":"text"},{"type":"text","text":"over existentials of the annotated protocol."}],"url":"\/documentation\/swiftconformableexistential\/equatableexistential(accessmodifier:)","title":"EquatableExistential(accessModifier:)","type":"topic","fragments":[{"text":"macro","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"EquatableExistential"},{"text":"(","kind":"text"},{"kind":"externalParam","text":"accessModifier"},{"text":": ","kind":"text"},{"kind":"typeIdentifier","preciseIdentifier":"s:17SwiftSyntaxExtras18TypeAccessModifierO","text":"TypeAccessModifier"},{"kind":"text","text":"?)"}],"role":"symbol","kind":"symbol"},"doc://SwiftConformableExistential/documentation/SwiftConformableExistential/HashableCodableExistential(accessModifier:)":{"title":"HashableCodableExistential(accessModifier:)","type":"topic","abstract":[{"type":"text","text":"Synthetizes "},{"type":"codeVoice","code":"Hashable & Codable"},{"type":"text","text":" property wrapper variants (regular, mutable, optional, collection and their combinations)"},{"type":"text","text":" "},{"text":"over existentials of the annotated protocol.","type":"text"}],"identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/HashableCodableExistential(accessModifier:)","kind":"symbol","fragments":[{"text":"macro","kind":"keyword"},{"text":" ","kind":"text"},{"text":"HashableCodableExistential","kind":"identifier"},{"text":"(","kind":"text"},{"text":"accessModifier","kind":"externalParam"},{"kind":"text","text":": "},{"text":"TypeAccessModifier","kind":"typeIdentifier","preciseIdentifier":"s:17SwiftSyntaxExtras18TypeAccessModifierO"},{"text":"?)","kind":"text"}],"url":"\/documentation\/swiftconformableexistential\/hashablecodableexistential(accessmodifier:)","role":"symbol"},"doc://SwiftConformableExistential/documentation/SwiftConformableExistential":{"identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential","kind":"symbol","url":"\/documentation\/swiftconformableexistential","abstract":[{"text":"A set of Swift Macros designed to facilitate the conformance of existential types to","type":"text"},{"text":" ","type":"text"},{"code":"Equatable","type":"codeVoice"},{"text":", ","type":"text"},{"code":"Hashable","type":"codeVoice"},{"type":"text","text":", "},{"type":"codeVoice","code":"Decodable"},{"type":"text","text":", "},{"code":"Encodable","type":"codeVoice"},{"text":", and ","type":"text"},{"type":"codeVoice","code":"Codable"},{"text":".","type":"text"}],"title":"SwiftConformableExistential","type":"topic","role":"collection"},"doc://SwiftConformableExistential/documentation/SwiftConformableExistential/MetaCoding":{"navigatorTitle":[{"text":"MetaCoding","kind":"identifier"}],"identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/MetaCoding","title":"MetaCoding","kind":"symbol","role":"symbol","abstract":[],"fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"MetaCoding"}],"url":"\/documentation\/swiftconformableexistential\/metacoding","type":"topic"},"doc://SwiftConformableExistential/documentation/SwiftConformableExistential/MetaDecoding":{"navigatorTitle":[{"kind":"identifier","text":"MetaDecoding"}],"abstract":[{"text":"A type that decodes meta information.","type":"text"}],"fragments":[{"text":"protocol","kind":"keyword"},{"kind":"text","text":" "},{"text":"MetaDecoding","kind":"identifier"}],"identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/MetaDecoding","url":"\/documentation\/swiftconformableexistential\/metadecoding","type":"topic","title":"MetaDecoding","kind":"symbol","role":"symbol"},"doc://SwiftConformableExistential/documentation/SwiftConformableExistential/EquatableCodableExistential(accessModifier:)":{"url":"\/documentation\/swiftconformableexistential\/equatablecodableexistential(accessmodifier:)","title":"EquatableCodableExistential(accessModifier:)","role":"symbol","fragments":[{"text":"macro","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"EquatableCodableExistential"},{"kind":"text","text":"("},{"kind":"externalParam","text":"accessModifier"},{"kind":"text","text":": "},{"kind":"typeIdentifier","preciseIdentifier":"s:17SwiftSyntaxExtras18TypeAccessModifierO","text":"TypeAccessModifier"},{"kind":"text","text":"?)"}],"identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/EquatableCodableExistential(accessModifier:)","abstract":[{"type":"text","text":"Synthetizes "},{"code":"Equatable & Codable","type":"codeVoice"},{"text":" property wrapper variants (regular, mutable, optional, collection and their combinations)","type":"text"},{"text":" ","type":"text"},{"text":"over existentials of the annotated protocol.","type":"text"}],"type":"topic","kind":"symbol"},"doc://SwiftConformableExistential/documentation/SwiftConformableExistential/DecodableExistential(accessModifier:)":{"role":"symbol","kind":"symbol","identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/DecodableExistential(accessModifier:)","fragments":[{"text":"macro","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"DecodableExistential"},{"text":"(","kind":"text"},{"text":"accessModifier","kind":"externalParam"},{"kind":"text","text":": "},{"preciseIdentifier":"s:17SwiftSyntaxExtras18TypeAccessModifierO","text":"TypeAccessModifier","kind":"typeIdentifier"},{"text":"?)","kind":"text"}],"type":"topic","url":"\/documentation\/swiftconformableexistential\/decodableexistential(accessmodifier:)","abstract":[{"text":"Synthetizes ","type":"text"},{"type":"codeVoice","code":"Decodable"},{"type":"text","text":" property wrapper variants (regular, mutable, optional, collection and their combinations)"},{"text":" ","type":"text"},{"text":"over existentials of the annotated protocol.","type":"text"}],"title":"DecodableExistential(accessModifier:)"},"doc://SwiftConformableExistential/documentation/SwiftConformableExistential/EquatableDecodableExistential(accessModifier:)":{"kind":"symbol","identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/EquatableDecodableExistential(accessModifier:)","role":"symbol","fragments":[{"kind":"keyword","text":"macro"},{"text":" ","kind":"text"},{"text":"EquatableDecodableExistential","kind":"identifier"},{"text":"(","kind":"text"},{"text":"accessModifier","kind":"externalParam"},{"text":": ","kind":"text"},{"kind":"typeIdentifier","preciseIdentifier":"s:17SwiftSyntaxExtras18TypeAccessModifierO","text":"TypeAccessModifier"},{"kind":"text","text":"?)"}],"abstract":[{"type":"text","text":"Synthetizes "},{"code":"Equatable & Decodable","type":"codeVoice"},{"type":"text","text":" property wrapper variants (regular, mutable, optional, collection and their combinations)"},{"type":"text","text":" "},{"text":"over existentials of the annotated protocol.","type":"text"}],"url":"\/documentation\/swiftconformableexistential\/equatabledecodableexistential(accessmodifier:)","type":"topic","title":"EquatableDecodableExistential(accessModifier:)"},"doc://SwiftConformableExistential/documentation/SwiftConformableExistential/EquatableEncodableExistential(accessModifier:)":{"title":"EquatableEncodableExistential(accessModifier:)","type":"topic","abstract":[{"type":"text","text":"Synthetizes "},{"type":"codeVoice","code":"Equatable & Encodable"},{"type":"text","text":" property wrapper variants (regular, mutable, optional, collection and their combinations)"},{"type":"text","text":" "},{"text":"over existentials of the annotated protocol.","type":"text"}],"identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/EquatableEncodableExistential(accessModifier:)","kind":"symbol","fragments":[{"text":"macro","kind":"keyword"},{"text":" ","kind":"text"},{"text":"EquatableEncodableExistential","kind":"identifier"},{"text":"(","kind":"text"},{"text":"accessModifier","kind":"externalParam"},{"kind":"text","text":": "},{"text":"TypeAccessModifier","kind":"typeIdentifier","preciseIdentifier":"s:17SwiftSyntaxExtras18TypeAccessModifierO"},{"text":"?)","kind":"text"}],"url":"\/documentation\/swiftconformableexistential\/equatableencodableexistential(accessmodifier:)","role":"symbol"},"doc://SwiftConformableExistential/documentation/SwiftConformableExistential/DetailedDesign#Composited-conformances":{"identifier":"doc:\/\/SwiftConformableExistential\/documentation\/SwiftConformableExistential\/DetailedDesign#Composited-conformances","type":"topic","title":"Composited conformances","kind":"section","url":"\/documentation\/swiftconformableexistential\/detaileddesign#Composited-conformances","abstract":[]}}}